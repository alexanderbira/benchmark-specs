# Represents the tree generated by the interpolation repair tool and methods to extract BCs from it

import ast
import re
from typing import Dict, List, Optional

import pandas as pd

from lib.bc.is_bc import is_bc
from lib.bc.results import Results
from lib.util.check_realizability import check_spectra_realizability


class InterpolationNode:
    """Represents a node in the interpolation tree."""

    def __init__(self, node_id: str, parent_node_id: Optional[str] = None,
                 is_realizable: bool = False, unreal_core: List[str] = None,
                 refinement: List[str] = None, **kwargs):
        """Initialize an interpolation node.

        Args:
            node_id: Unique identifier for this node
            parent_node_id: ID of the parent node (None for root)
            is_realizable: Whether this node is realizable
            unreal_core: List of unrealizable core formulas
            refinement: List of refinement formulas
            **kwargs: Additional node data from the CSV
        """
        self.node_id = node_id
        self.parent_node_id = parent_node_id
        self.is_realizable = is_realizable
        self.unreal_core = unreal_core or []
        self.refinement = refinement or []
        self.children: List[InterpolationNode] = []

        # Store all other CSV data
        self.data = kwargs

    def add_child(self, child: 'InterpolationNode'):
        """Add a child node."""
        self.children.append(child)

    def __repr__(self):
        return f"Node({self.node_id[:8]}..., realizable={self.is_realizable}, children={len(self.children)})"


class InterpolationTree:
    """Represents a tree of interpolation nodes."""

    def __init__(self):
        self.nodes: Dict[str, InterpolationNode] = {}
        self.root: Optional[InterpolationNode] = None
        self._check_refinement_cache: Dict[tuple, bool] = {}

    def add_node(self, node: InterpolationNode):
        """
        Add a node to the tree.

        Args:
            node: The InterpolationNode to add
        """
        self.nodes[node.node_id] = node

        # If this is a root node (no parent), set as root
        if node.parent_node_id is None or node.parent_node_id == '':
            self.root = node
        else:
            # Add as child to parent if parent exists
            parent = self.nodes.get(node.parent_node_id)
            if parent:
                parent.add_child(node)

    def get_node(self, node_id: str) -> Optional[InterpolationNode]:
        """
        Get a node by its ID.

        Args:
            node_id: The ID of the node to retrieve
        Returns:
            The InterpolationNode if found, else None
        """
        return self.nodes.get(node_id)

    def _check_refinement(self, assumptions, refinement, guarantees, spec_without_guarantees, results):
        """
        Check if a refinement correlates to boundary condition and add to results if found.

        Args:
            assumptions: List of assumption formulas (LTL strings)
            refinement: The refinement formula to check (LTL string)
            guarantees: List of guarantee formulas (LTL strings)
            spec_without_guarantees: The specification without guarantees (in Spectra format)
            results: The Results object to add found BCs to
        """
        # Create cache key using bc_candidate and guarantees
        cache_key = (refinement, tuple(guarantees))

        if cache_key in self._check_refinement_cache:
            # Already processed this refinement, no need to re-add to results
            return

        # Convert refinement to proper LTL syntax for is_bc
        # replace "next" with X
        phi = re.sub(r'next', 'X', refinement)
        # replace "alwEv" with G F
        phi = re.sub(r'alwEv', 'G F', phi)
        # replace "alw" with G
        phi = re.sub(r'alw', 'G', phi)
        phi = "!(" + phi + ")"  # Negate refinement to create BC candidate

        # Check if the candidate is a boundary condition
        candidate_is_bc = is_bc(assumptions, guarantees, phi)
        if not candidate_is_bc:
            self._check_refinement_cache[cache_key] = False
            return

        # Now check unrealizability of domains -> !phi
        # Note: !phi is equivalent to the original refinement, since phi = !(refinement)

        # Convert refinement to Spectra syntax for unrealizability check
        # replace "alwEv" with GF
        not_phi = re.sub(r'alwEv', 'GF', refinement)
        # replace "alw" with G
        not_phi = re.sub(r'alw', 'G', not_phi)
        spec_to_check = spec_without_guarantees + "\nguarantee " + not_phi + ";"

        is_ubc = not check_spectra_realizability(spec_to_check)
        results.add_bc(phi, guarantees, is_ubc)

        # Mark as processed in cache
        self._check_refinement_cache[cache_key] = True

    def find_bcs(self, spec, assumptions, spec_without_guarantees, verbose=False):
        """
        Process all refinements in the tree and return Results.

        Args:
            spec: The original specification dictionary
            assumptions: List of assumption formulas (LTL strings)
            spec_without_guarantees: The specification without (guarantees in Spectra format)
            verbose: Whether to print verbose output

        Returns:
            Results object containing found BCs
        """

        results = Results(spec)

        if not self.root:
            if verbose:
                print("No root node found in tree")
            return results

        self._process_node(self.root, assumptions, spec_without_guarantees, results)

        return results

    def _process_node(self, node: InterpolationNode, assumptions, spec_without_guarantees, results):
        """
        Process a single node and its children (DFS).

        Args:
            node: The current InterpolationNode to process
            assumptions: List of assumption formulas (LTL strings)
            spec_without_guarantees: The specification without (guarantees in Spectra format)
            results: The Results object to add found BCs to
        """

        # Skip root node refinements as they're always empty
        if node.parent_node_id is not None and node.parent_node_id != '':
            parent = self.nodes.get(node.parent_node_id)
            if parent:
                # Process parent's unrealizable core (use as guarantees)
                parent_unreal_core = parent.unreal_core.copy()

                # Format parent_unreal_core from Spectra to LTL
                # Replace "next" with X
                parent_unreal_core = [re.sub(r'next', 'X', expr.strip()) for expr in parent_unreal_core]
                # Replace "GF" with "G F"
                parent_unreal_core = [re.sub(r'GF', 'G F', expr) for expr in parent_unreal_core]

                # Process each refinement in this node
                for refinement in node.refinement:
                    self._check_refinement(assumptions, refinement, parent_unreal_core, spec_without_guarantees,
                                           results)

        # Recursively process children (DFS)
        for child in node.children:
            self._process_node(child, assumptions, spec_without_guarantees, results)


def safe_eval(value):
    """
    Safely evaluate a string representation of a list.

    Args:
        value: The string to evaluate

    Returns:
        A list of strings
    """
    if pd.isna(value) or value == '':
        return []

    try:
        # Handle the case where it's already a list
        if isinstance(value, list):
            return value

        # Try to evaluate as Python literal
        return ast.literal_eval(value)
    except (ValueError, SyntaxError):
        # If it fails, return as single item list
        return [str(value)]


def build_interpolation_tree(csv_path: str) -> InterpolationTree:
    """Build an interpolation tree from a CSV file.

    Args:
        csv_path: Path to the CSV file containing interpolation nodes

    Returns:
        InterpolationTree: The constructed tree
    """
    df = pd.read_csv(csv_path)
    tree = InterpolationTree()

    # First pass: create all nodes with original refinements
    nodes_to_process = []
    for _, row in df.iterrows():
        # Parse the refinement and unreal_core fields
        refinement = safe_eval(row.get('refinement', []))
        unreal_core = safe_eval(row.get('unreal_core', []))

        # Create node data dictionary excluding the fields we handle specially
        node_data = row.to_dict()
        for key in ['node_id', 'parent_node_id', 'is_realizable', 'refinement', 'unreal_core']:
            node_data.pop(key, None)

        node = InterpolationNode(
            node_id=row['node_id'],
            parent_node_id=row['parent_node_id'] if pd.notna(row['parent_node_id']) else None,
            is_realizable=row['is_realizable'],
            unreal_core=unreal_core,
            refinement=refinement,  # Keep original refinement for now
            **node_data
        )

        tree.add_node(node)
        nodes_to_process.append(node)

    # Second pass: establish parent-child relationships and filter refinements
    for node in nodes_to_process:
        if node.parent_node_id and node.parent_node_id in tree.nodes:
            parent = tree.nodes[node.parent_node_id]
            if node not in parent.children:
                parent.add_child(node)

            # Filter out parent refinements from this node's refinements
            parent_refinements = set(parent.refinement)
            node.refinement = [ref for ref in node.refinement if ref not in parent_refinements]

    return tree
